#######################################################
# This stub is autogenerated
########################################################

import numbers
import typing
import geometry_msgs.msg._Pose
import trajectory_msgs.msg._JointTrajectory
import enum
import PyKDL
import movej_ik_server.arm_configs
import pint.util
import rospy.rostime


class JointsFactory(object, metaclass=type):
	def __getitem__(self, values):
		...
	def __call__(self, args, kwargs):
		...
	...

class Joints(object, metaclass=type):
	def copy(self) -> Joints:
		"""
		Creates a copy of the joints object.
		
		:return: Copy of the joints object.
		"""
		...
	def to_list(self) -> typing.List[float]:
		"""
		Convert the joints object to a list of joint positions.
		
		:return: List of the six joint positions.
		"""
		...
	def with_units(self, angular_unit: typing.Union[str, pint.util.SharedRegistryObject, None] = None) -> Joints:
		"""
		Adds a unit type to all positions of the joints object. The defaults are
		the native ROS units. In case a joint position already has units, the
		unit type is converted accordingly.
		
		:param angular_unit: Unit type for the angular joint positions.
		:return: The resulting joints object.
		"""
		...
	def without_units(self, angular_unit: typing.Union[str, pint.util.SharedRegistryObject, None] = None) -> Joints:
		"""
		Removes units from the joint positions if any. If no unit type is
		specified ROS units are assumed.
		
		:param angular_unit: Unit type for the angular joint positions.
		:return: The resulting joints object.
		"""
		...
	def to_ros_units(self, angular_unit: typing.Union[str, pint.util.SharedRegistryObject, None] = None) -> Joints:
		"""
		Converts the joints object to native ROS units, removing the unit type
		if any. This is useful if you want to send the resulting data to a ROS
		service.
		
		:param angular_unit: Unit type for the angular joint positions.
		:return: The resulting joints object.
		"""
		...
	def from_ros_units(self, angular_unit: typing.Union[str, pint.util.SharedRegistryObject, None] = None):
		"""
		Converts the joints object from native ROS units to the target units,
		removing the unit type if any.
		
		:param angular_unit: Unit type for the angular joint positions.
		:return: The resulting joints object.
		"""
		...
	def __getstate__(self):
		"""
		Automatically created by attrs.
		"""
		...
	def __setstate__(self, state):
		"""
		Automatically created by attrs.
		"""
		...
	def __repr__(self):
		"""
		"""
		...
	def __eq__(self, other):
		"""
		"""
		...
	def __ne__(self, other):
		"""
		"""
		...
	def __lt__(self, other):
		"""
		"""
		...
	def __le__(self, other):
		"""
		"""
		...
	def __gt__(self, other):
		"""
		"""
		...
	def __ge__(self, other):
		"""
		"""
		...
	def __init__(self, j1: float = 0.0, j2: float = 0.0, j3: float = 0.0, j4: float = 0.0, j5: float = 0.0, j6: float = 0.0) -> None:
		"""
		"""
		...
	...

class PoseFactory(object, metaclass=type):
	def __getitem__(self, values):
		...
	def __call__(self, args, kwargs):
		...
	...

class Pose(object, metaclass=type):
	def copy(self) -> Pose:
		"""
		Creates a copy of the pose object.
		
		:return: A copy of the pose.
		"""
		...
	def to_list(self) -> typing.List[float]:
		"""
		Convert the pose to a list of the coordinates.
		:return: List of the six coordinates.
		"""
		...
	def to_ros_pose(self) -> geometry_msgs.msg._Pose.Pose:
		"""
		Converts the pose object to a native ROS pose.
		
		:return: ROS pose.
		"""
		...
	def to_kdl_frame(self) -> PyKDL.Frame:
		"""
		Converts the pose object to a KDL frame.
		
		:return: KDL frame.
		"""
		...
	def with_units(self, linear_unit: typing.Union[str, pint.util.SharedRegistryObject, None] = None, angular_unit: typing.Union[str, pint.util.SharedRegistryObject, None] = None) -> Pose:
		"""
		Adds a unit type to all coordinates of the pose. The defaults are the
		native ROS units. In case a coordinate already has units, the unit type
		is converted accordingly.
		
		:param linear_unit: Unit type for linear coordinates.
		:param angular_unit: Unit type for angular coordinates.
		:return: The resulting pose.
		"""
		...
	def without_units(self, linear_unit: typing.Union[str, pint.util.SharedRegistryObject, None] = None, angular_unit: typing.Union[str, pint.util.SharedRegistryObject, None] = None) -> Pose:
		"""
		Removes units from the coordinates if any. If no unit type is specified
		ROS units are assumed.
		
		:param linear_unit: Unit type for linear coordinates.
		:param angular_unit: Unit type for angular coordinates.
		:return: The resulting pose.
		"""
		...
	def to_ros_units(self, linear_unit: typing.Union[str, pint.util.SharedRegistryObject, None] = None, angular_unit: typing.Union[str, pint.util.SharedRegistryObject, None] = None) -> Pose:
		"""
		Converts the pose to native ROS units, removing the unit type if any.
		This is useful if you want to send the resulting data to a ROS service.
		
		:param linear_unit: Unit type for linear coordinates.
		:param angular_unit: Unit type for angular coordinates.
		:return: The resulting pose.
		"""
		...
	def from_ros_units(self, linear_unit: typing.Union[str, pint.util.SharedRegistryObject, None] = None, angular_unit: typing.Union[str, pint.util.SharedRegistryObject, None] = None):
		"""
		Converts the pose from native ROS units to the target units, removing
		the unit type.
		
		:param linear_unit: Unit type for linear coordinates.
		:param angular_unit: Unit type for angular coordinates.
		:return: The resulting pose.
		"""
		...
	def inverse(self) -> Pose:
		"""
		Creates the inverse of the pose. Useful for calculating frames.
		
		:return: New pose object.
		"""
		...
	def __mul__(self, other: Pose) -> Pose:
		"""
		Use KDL frame multiplication to apply a frame to a pose.
		
		:param other: Other pose.
		:return: New pose object.
		
		.. code-block:: python
		
		new_wp = Pose(x=10) * waypoint_1 # translates waypoint_1 by x=10
		old_wp = Pose(x=10).inverse() * new_wp # translates new_wp back
		"""
		...
	def __getstate__(self):
		"""
		Automatically created by attrs.
		"""
		...
	def __setstate__(self, state):
		"""
		Automatically created by attrs.
		"""
		...
	def __repr__(self):
		"""
		"""
		...
	def __eq__(self, other):
		"""
		"""
		...
	def __ne__(self, other):
		"""
		"""
		...
	def __lt__(self, other):
		"""
		"""
		...
	def __le__(self, other):
		"""
		"""
		...
	def __gt__(self, other):
		"""
		"""
		...
	def __ge__(self, other):
		"""
		"""
		...
	def __init__(self, x: typing.Union[numbers.Number, pint.util.Quantity] = 0.0, y: typing.Union[numbers.Number, pint.util.Quantity] = 0.0, z: typing.Union[numbers.Number, pint.util.Quantity] = 0.0, a: typing.Union[numbers.Number, pint.util.Quantity] = 0.0, b: typing.Union[numbers.Number, pint.util.Quantity] = 0.0, c: typing.Union[numbers.Number, pint.util.Quantity] = 0.0, frame: str = '', conf: movej_ik_server.arm_configs.JointConfig = None, rev: typing.Union[numbers.Number, pint.util.Quantity] = None) -> None:
		"""
		"""
		...
	...

class RobotProgramError(Exception, metaclass=type):
	...

class MoveError(RobotProgramError, metaclass=type):
	...

class MoveExecutionError(MoveError, metaclass=type):
	def __init__(self, message = None, error_code = None):
		...
	...

class MovePlanningError(MoveError, metaclass=type):
	...

class PathToleranceError(MoveExecutionError, metaclass=type):
	def __init__(self, error_code = None):
		...
	...

class GoalToleranceError(MoveExecutionError, metaclass=type):
	def __init__(self, error_code = None):
		...
	...

class ProbeError(MoveExecutionError, metaclass=type):
	...

class ProbeUnexpectedContactError(ProbeError, metaclass=type):
	def __init__(self, error_code = None):
		...
	...

class ProbeContactAtStartError(ProbeError, metaclass=type):
	def __init__(self, error_code = None):
		...
	...

class ProbeFailedError(ProbeError, metaclass=type):
	def __init__(self, error_code = None):
		...
	...

class PathPilotError(RobotProgramError, metaclass=type):
	def __init__(self, message: str, instance: str):
		...
	...

class PathPilotInstanceNotConnectedError(PathPilotError, metaclass=type):
	...

class PathPilotInstanceNotFoundError(PathPilotError, metaclass=type):
	...

class InterruptSource(enum.IntEnum, metaclass=enum.EnumMeta):
	def _generate_next_value_(name, start, count, last_values):
		"""
		Generate the next value when not given.
		
		name: the name of the member
		start: the initial start value or None
		count: the number of existing members
		last_value: the last value assigned or None
		"""
		...
	def __new__(cls, value):
		...
	...

class JointConfig(enum.Flag, metaclass=enum.EnumMeta):
	def _generate_next_value_(name, start, count, last_values):
		"""
		Generate the next value when not given.
		
		name: the name of the member
		start: the initial start value or None
		count: the number of existing members
		last_value: the last value assigned or None
		"""
		...
	def __and__(self, other):
		...
	def __new__(cls, value):
		...
	...

name: str

NUT: movej_ik_server.arm_configs.JointConfig

NDT: movej_ik_server.arm_configs.JointConfig

NUB: movej_ik_server.arm_configs.JointConfig

NDB: movej_ik_server.arm_configs.JointConfig

FUT: movej_ik_server.arm_configs.JointConfig

FDT: movej_ik_server.arm_configs.JointConfig

FUB: movej_ik_server.arm_configs.JointConfig

FDB: movej_ik_server.arm_configs.JointConfig

NUx: movej_ik_server.arm_configs.JointConfig

NDx: movej_ik_server.arm_configs.JointConfig

FUx: movej_ik_server.arm_configs.JointConfig

FDx: movej_ik_server.arm_configs.JointConfig

NxT: movej_ik_server.arm_configs.JointConfig

NxB: movej_ik_server.arm_configs.JointConfig

FxT: movej_ik_server.arm_configs.JointConfig

FxB: movej_ik_server.arm_configs.JointConfig

xUT: movej_ik_server.arm_configs.JointConfig

xDT: movej_ik_server.arm_configs.JointConfig

xUB: movej_ik_server.arm_configs.JointConfig

xDB: movej_ik_server.arm_configs.JointConfig

Nxx: movej_ik_server.arm_configs.JointConfig

Fxx: movej_ik_server.arm_configs.JointConfig

xUx: movej_ik_server.arm_configs.JointConfig

xDx: movej_ik_server.arm_configs.JointConfig

xxT: movej_ik_server.arm_configs.JointConfig

xxB: movej_ik_server.arm_configs.JointConfig

ALL: movej_ik_server.arm_configs.JointConfig

p: PoseFactory

j: JointsFactory

def init_rpl_interpreter(interpreter):
	...

def movel(target: typing.Union[Pose, Joints], a: float = None, v: float = None, probe: int = 0, velocity: typing.Union[float, pint.util.Quantity, None] = None, accel: typing.Union[float, pint.util.Quantity, None] = None, accel_scale: float = 0.5, duration: typing.Union[float, pint.util.Quantity, None] = None, strict_limits: bool = False) -> typing.Union[typing.Tuple[int, rospy.rostime.Time, Joints, Pose], None]:
	"""
	Moves the robot end effector in a straight line from the current position to
	the target waypoint. Targets can be local waypoints or global waypoints
	defined as pose or joints.
	
	:param target: target waypoint
	:param probe: specify the probe mode (2-6, or 0 for no probing)
	Probe mode 2: look for rising edge on probe signal (i.e. contact), raise ProbeFailedError if move completes without seeing a rising edge
	Probe mode 3: like mode 2 but does not raise error if move completes without rising edge
	Probe mode 4: like mode 2 but looks for falling edge
	Probe mode 5: like mode 4 but does not raise an error if move completes without falling edge
	Probe mode 6: "retract" mode, ignore falling edges and allow motion while probe signal is active, but raise ProbeUnexpectedContactError if a rising edge is seen
	:param velocity: move velocity as absolute value, interpreted
	in terms of currently set machine units if quantity without units is given.
	:param accel: move acceleration as absolute value, interpreted
	in terms of currently set machine units if quantity without units is given.
	:param accel_scale: move acceleration scaling factor 0.0 - 1.0
	:param duration: target move duration in seconds. If move duration based on
	other inputs is longer, the planned duration will be used.
	:param strict_limits: Enforces strict limits. Moves violating
	the velocity and acceleration limits will error.
	
	:return: tuple of probe results:
	(probe contact type (0 = no contact, 1 = rising, 2 = falling),
	time of probe contact,
	Joint positions at probe contact,
	End-effector position / orientation pose at probe contact)
	
	:param v: move velocity scaling factor 0.0 - 1.0
	
	.. deprecated:: 3.1.1
	use velocity instead
	
	:param a: move acceleration scaling factor 0.0 - 1.0
	
	.. deprecated:: 3.1.1
	use accel_scale instead
	
	**Examples**
	
	.. code-block:: python
	
	movel(waypoint_1)
	movel("global_waypoint_1", velocity=100)
	movel(j[0.764, 1.64, 0.741, 0.433, 0.140, 2.74])
	"""
	...

def movej(target: typing.Union[Pose, Joints], v: float = None, probe: int = 0, velocity_scale: float = 1.0) -> typing.Union[typing.Tuple[int, rospy.rostime.Time, Joints, Pose], None]:
	"""
	
	Moves the robot end effector to the target waypoint with a joints move.
	Targets can be local waypoints or global waypoints defined as pose or
	joints.
	
	:param target: target waypoint or joints target
	:param velocity_scale: scale factor for velocity (default is full speed)
	:param probe: specify the probe mode (2-6, or 0 for no probing)
	Probe mode 2: look for rising edge on probe signal (i.e. contact), raise ProbeFailedError if move completes without seeing a rising edge
	Probe mode 3: like mode 2 but does not raise error if move completes without rising edge
	Probe mode 4: like mode 2 but looks for falling edge
	Probe mode 5: like mode 4 but does not raise an error if move completes without falling edge
	Probe mode 6: "retract" mode, ignore falling edges and allow motion while probe signal is active, but raise ProbeUnexpectedContactError if a rising edge is seen
	
	:return: tuple of probe results (for probing mode 2,3,4,5) or None:
	(probe contact type (0 = no contact, 1 = rising, 2 = falling),
	time of probe contact,
	Joint positions at probe contact,
	End-effector position / orientation pose at probe contact)
	
	:param v: scale factor for velocity (default is full speed)
	
	.. deprecated:: 3.1.1
	use velocity_scale instead
	
	**Examples**
	
	.. code-block:: python
	
	movej(waypoint_1)
	movej("global_waypoint_1", velocity_scale=0.6)
	movej(p[0, 100, 0, 90, 20, 0])
	"""
	...

def movef(target: typing.Union[Pose, Joints]) -> None:
	"""
	Free move command.
	
	:param target: target target
	"""
	...

def movec(interim: typing.Union[Pose, Joints], target: typing.Union[Pose, Joints], a: float = None, v: float = None, probe: int = 0, velocity: typing.Union[float, pint.util.Quantity, None] = None, accel: typing.Union[float, pint.util.Quantity, None] = None, accel_scale: float = 0.5, duration: typing.Union[float, pint.util.Quantity, None] = None, strict_limits: bool = False) -> typing.Union[typing.Tuple[int, rospy.rostime.Time, Joints, Pose], None]:
	"""
	Circular/Arc move command.
	
	:param interim: interim waypoint
	:param target: target waypoint
	:param probe: specify the probe mode (2-6, or 0 for no probing)
	Probe mode 2: look for rising edge on probe signal (i.e. contact), raise ProbeFailedError if move completes without seeing a rising edge
	Probe mode 3: like mode 2 but does not raise error if move completes without rising edge
	Probe mode 4: like mode 2 but looks for falling edge
	Probe mode 5: like mode 4 but does not raise an error if move completes without falling edge
	Probe mode 6: "retract" mode, ignore falling edges and allow motion while probe signal is active, but raise ProbeUnexpectedContactError if a rising edge is seen
	:param velocity: move velocity as absolute value, interpreted
	in terms of currently set machine units if quantity without units is given.
	:param accel: move acceleration as absolute value, interpreted
	in terms of currently set machine units if quantity without units is given.
	:param accel_scale: move acceleration scaling factor 0.0 - 1.0
	:param duration: target move duration in seconds. If move duration based on
	other inputs is longer, the planned duration will be used.
	:param strict_limits: Enforces strict limits. Moves violating
	the velocity and acceleration limits will error.
	
	:return: tuple of probe results (for probing mode 2,3,4,5) or None:
	(probe contact type (0 = no contact, 1 = rising, 2 = falling),
	time of probe contact,
	Joint positions at probe contact,
	End-effector position / orientation pose at probe contact)
	
	:param v: move velocity scaling factor 0.0 - 1.0
	
	.. deprecated:: 3.1.1
	use velocity instead
	
	:param a: move acceleration scaling factor 0.0 - 1.0
	
	.. deprecated:: 3.1.1
	use accel_scale instead
	
	**Examples**
	
	.. code-block:: python
	
	movec(waypoint_1, waypoint_2)
	"""
	...

def probel(target: typing.Union[Pose, Joints, str], a: float = 0.5, v: float = 0.1, v_retract: float = 0.1, away: bool = False, check_retract_contact: bool = False) -> Pose:
	"""
	Simple probing cycle that returns to the initial pose (regardless of the
	probe result). The sequence is:
	
	1) Linear move at specified vel / accel scale towards the target position
	2) Stop at probe contact, error condition, or motion end
	3) Retract to original position
	4) Raise any errors from the cycle, or return the probe result
	
	:param target: end point of probing motion (probe cycle uses movel internally)
	:param v: move velocity scaling factor 0.0 - 1.0
	:param a: move acceleration scaling factor 0.0 - 1.0
	:param v_retract: velocity scaling factor to use during retract phase
	:param away: Probe towards work (default) if False, otherwise probe away from work
	:param check_retract_contact: Optionally check for contacts during
	retract move (to avoid retracting into an obstacle and breaking a probe tip)
	
	.. note:: assumes mode 2/4 for probing, meaning an error will be thrown if it reaches the end without contact.
	Caller can catch this exception if they want mode 3/5 functionality
	
	**Examples**
	
	.. code-block:: python
	
	contact_pose = probel(probe_goal_pose, a=0.5, v=0.01, v_retract=0.1, away=False, check_retract_contact=False)
	
	"""
	...

def get_digital_in(nr_or_name: typing.Union[str, int]) -> bool:
	"""
	Returns the current digital input state.
	
	:param nr_or_name: The number or name of the digital output pin.
	:return: True or False for High and Low.
	
	**Examples**
	
	.. code-block:: python
	
	io_state = get_digital_in("gripper")
	x = get_digital_in(3)
	"""
	...

def set_digital_out(nr_or_name: typing.Union[int, str], state: bool) -> None:
	"""
	Sets a digital output pin to high or low state.
	
	:param nr_or_name: The number or name of the digital output pin.
	:param state: Set to True or False for on and off.
	
	**Examples**
	
	.. code-block:: python
	
	set_digital_out("gripper", True)
	set_digital_out(2, False)
	"""
	...

def sync() -> None:
	"""
	The sync command is used in wait cycles and to force the execution of queued
	move commands.
	"""
	...

def sleep(secs: float) -> None:
	"""
	The sleep command pauses the program execution for ``t`` seconds.
	
	:param secs: sleep time in seconds
	
	**Examples**
	
	.. code-block:: python
	
	sleep(5.0)
	"""
	...

def notify(message: str, warning: bool = False, error: bool = False, image_path: str = '', timeout: typing.Union[float, None] = None) -> None:
	"""
	Creates a popup notification message on the robot UI.
	
	The ``message`` argument text is shown to the user.
	
	By default, the message is displayed as informational and thus will not
	block the program flow. The ``warning`` argument shows a warning message,
	which breaks program flow and can be declined by the operator. The ``error``
	argument shows a blocking error message, which aborts the program.
	
	The optional ``image_path`` argument can be used to display an informational
	image along with the message
	
	:param message: Message text to display in the popup.
	:param warning: Set to true if this message is a warning.
	:param error: Set to true if this message is an error message.
	:param image_path: Optional path to an image file to displayed in the popup.
	:param timeout: Optional timeout in seconds.
	
	**Examples**
	
	.. code-block:: python
	
	notify("Hello World!")
	notify("No part found, check the palette.", warning=True)
	notify("This should not happen.", error=True, image_path="./fatal_error.png")
	"""
	...

def input(message: str, default: str = '', image_path: str = '') -> float:
	"""
	Creates a popup input dialog on the robot UI.
	
	The ``message`` argument text is shown to the user.
	
	The ``option`` default argument can be used to set the default input text.
	
	The optional ``image_path`` argument can be used to display an informational
	image along with the message.
	
	:param message: Message text to display in the popup.
	:param default: The default input value.
	:param image_path: Optional path to an image file to displayed in the popup.
	:return: User input text or None if cancelled
	
	**Examples**
	
	.. code-block:: python
	
	user_input = input("How many parts should be made?", default="5")
	n = int(user_input)
	"""
	...

def pathpilot_mdi(command: str, instance: str = '') -> None:
	"""
	Starts an MDI command on the remote PathPilot instance. If no instance
	argument is given, the command is executed on the first connected PathPilot
	instance.
	
	:param command: MDI command to execute.
	:param instance: PathPilot instance on which this command shall be executed.
	
	**Examples**
	
	.. code-block:: python
	
	pathpilot_mdi("G0 X10")
	pathpilot_mdi("G1 Y-5 F300", "right_mill")
	"""
	...

def pathpilot_cycle_start(instance: str = '') -> None:
	"""
	Starts a cycle on the remote PathPilot instance. If no instance argument is
	given, the command is executed on the first connected PathPilot instance.
	
	:param instance: PathPilot instance on which cycle start should be executed.
	
	**Examples**
	
	.. code-block:: python
	
	pathpilot_cycle_start()
	pathpilot_cycle_start("left_mill")
	"""
	...

def get_joint_values() -> Joints:
	"""
	Returns the current joint values.
	
	:return: Current joint values.
	
	**Examples**
	
	.. code-block:: python
	
	joint_value = get_joint_values()
	"""
	...

def get_pose(apply_user_frame: bool = True, apply_tool_frame: bool = True) -> Pose:
	"""
	Returns the current robot pose.
	
	:param apply_user_frame: Applies the active user frame to the world pose.
	:param apply_tool_frame: Applies the active tool frame to the world pose.
	:return: Current robot pose.
	
	**Examples**
	
	.. code-block:: python
	
	current_pose = get_pose()
	"""
	...

def pause(optional: bool = False, active: bool = False) -> None:
	"""
	The pause command pauses the program execution. Equivalent to M01 break.
	
	The ``optional`` states whether the pause is optional or not. Optional pause
	can be enabled in the robot UI by the operator.
	
	:param optional: If this pause is optional or not.
	:param active: When set to true, this indicates an active pause allowing to operator to jog the program.
	
	**Examples**
	
	.. code-block:: python
	
	pause()
	pause(optional=True)
	"""
	...

def set_user_frame(name: str, pose: typing.Union[Pose, str, None] = None, position: typing.Union[Pose, str, None] = None, orientation: typing.Union[Pose, str, None] = None) -> None:
	"""
	Sets a user frame using a pose, position or orientation or clears an frame.
	
	The position and orientation arguments can be combined to overwrite the
	pose’s position or orientation.
	
	:param name: Name of the user frame
	:param pose: Pose to use for the user frame
	:param position: Use the position of this pose to override the position of the pose.
	:param orientation: Use the orientation of this pose to override the orientation of the pose.
	
	**Examples**
	
	.. code-block:: python
	
	set_user_frame("table", p[0, 100, 0, 0, 0, 0])
	set_user_frame("frame_1", waypoint_2, orientation=Pose(a=90))
	set_user_frame("frame_1") # clears frame_1
	"""
	...

def set_tool_frame(name: str, pose: typing.Union[Pose, str] = None, position: typing.Union[Pose, str] = None, orientation: typing.Union[Pose, str] = None) -> None:
	"""
	Sets a tool frame using a pose, position or orientation or clears an frame.
	
	The position and orientation arguments can be combined to overwrite the
	pose’s position or orientation.
	
	:param name: Name of the tool frame
	:param pose: Pose to use for the tool frame
	:param position: Use the position of this pose to override the position of the pose.
	:param orientation: Use the orientation of this pose to override the orientation of the pose.
	
	**Examples**
	
	.. code-block:: python
	
	set_tool_frame("some_tool", p[0, 0, 100, 0, 0, 0])
	set_tool_frame("other_tool", waypoint_2, position=Pose(z=0.1))
	set_tool_frame("other_tool") # clears frame other_tool
	"""
	...

def get_user_frame(name: str) -> typing.Union[Pose, None]:
	"""
	Returns the pose of a user frame.
	
	:param name: Name of the user frame.
	:return: Pose of the user frame.
	:raises TypeError: if no user frame with the name is found
	
	**Examples**
	
	.. code-block:: python
	
	pose = get_user_frame("table")
	"""
	...

def get_active_user_frame() -> str:
	"""
	Returns the name of the active user frame.
	
	**Examples**
	
	.. code-block:: python
	
	active_user_frame_name = get_active_user_frame()
	"""
	...

def get_tool_frame(name: str) -> typing.Union[Pose, None]:
	"""
	Returns the pose of a tool frame.
	
	:param name: Name of the tool frame.
	:return: Pose of the user frame or None if it does not exist.
	:raises TypeError: if no tool frame with the name is found
	
	**Examples**
	
	.. code-block:: python
	
	pose = get_tool_frame("tool1")
	"""
	...

def get_active_tool_frame() -> str:
	"""
	Returns the name of the active tool frame.
	
	**Examples**
	
	.. code-block:: python
	
	active_tool_frame_name = get_active_tool_frame()
	"""
	...

def change_user_frame(name: typing.Union[str, None]) -> None:
	"""
	Change the currently active user frame. If an empty string or ``None`` is
	used as the name parameter, the empty user frame *world* becomes active.
	
	:param name: The name of the tool frame to activate or `None` to disable user frames.
	
	**Examples**
	
	.. code-block:: python
	
	change_user_frame("table")
	change_user_frame(None) # disable any active frames
	"""
	...

def change_tool_frame(name: typing.Union[str, None]) -> None:
	"""
	Change the currently active tool frame. If an empty string or ``None`` is
	used as the name parameter, the empty tool frame *none* becomes active.
	
	:param name: The name of the tool frame to activate or `None` to disable tool frames.
	
	**Examples**
	
	.. code-block:: python
	
	change_tool_frame("table")
	change_tool_frame(None) # disable any active frames
	"""
	...

def user_frame(pose = None, position = None, orientation = None, world = False):
	"""
	Scoped frame command. Applies a user frame temporarily on top of the
	currently active user frame.
	
	The scoped frame command can be used to automatically switch the active
	frame back to a previous state when the scope is left. Scoped frames
	can be nested. Scoped frames are temporary and do not have a name.
	
	:param pose: The frame pose.
	:param position: A pose from which the position is used for the frame.
	:param orientation: A pose from which the orientation is used for the frame.
	:param world: If set to True the frame is absolute.
	
	**Examples**
	
	.. code-block:: python
	
	with user_frame(p[0, 100, 0, 90, 20, 0]): # creates a temporary frame and activates it
	movel(Pose(x=10)) # move x by 10 starting from the frame
	# the active frame automatically reset when the scope is left
	"""
	...

def get_pathpilot_state(instance: str = '') -> str:
	"""
	Returns the current state of a PathPilot instance. If no instance argument
	is given, the command is executed on the first connected PathPilot instance.
	
	Possible states are:
	
	* “disconnected” - Instance disconnected
	* “estop” - Emergency stop active
	* “running” - a program is running
	* “ready” - instance is ready to start program
	* “idle” - instance is idle, no program loaded
	
	:param instance: PathPilot instance on which cycle start should be executed.
	:return: The current PathPilot state.
	
	**Examples**
	
	.. code-block:: python
	
	state = get_pathpilot_instance()
	while get_pathpilot_instance("left_mill") != "ready":
	sleep(0.1)
	"""
	...

def get_global_waypoint(name: str) -> typing.Union[Pose, Joints, None]:
	"""
	Get global waypoint pose or joints value.
	
	:param name: Name of the global waypoint.
	:return: Pose or Joints of the global waypoint or None if it does not exist.
	
	**Examples**
	
	.. code-block:: python
	
	point = get_global_waypoint("point")
	"""
	...

def set_global_waypoint(name: str, value: typing.Union[Pose, Joints]) -> None:
	"""
	Set global waypoint pose or joints value.
	
	:param name: Name of the global waypoint
	:param value: Pose or joints value
	
	**Examples**
	
	.. code-block:: python
	
	set_global_waypoint("point", p[500.0, 0.0, 900.0, 0.0, -90.0, 0.0])
	"""
	...

def set_units(linear: typing.Union[str, pint.util.SharedRegistryObject, None] = None, angular: typing.Union[str, pint.util.SharedRegistryObject, None] = None, time: typing.Union[str, pint.util.SharedRegistryObject, None] = None):
	"""
	Sets the active linear, angular and time units for the program.
	
	:param linear: Linear/length unit type: m, mm, inch
	:param angular: Angular/rotation unit type: deg, rad
	:param time: Time unit type: s, min, h
	
	**Examples**
	
	.. code-block:: python
	
	set_units("mm", "deg", "s")
	set_units(linear="in")
	set_units(angular="rad")
	set_units(time="s")
	"""
	...

def get_units(with_time: bool = False) -> typing.Union[typing.Tuple[str, str], typing.Tuple[str, str, str]]:
	"""
	Returns the active linear, angular and time units from the program.
	
	:param time: return the time unit type when set to True
	
	:return: Linear/length unit type, angular/rotation unit type and time unit type
	
	**Examples**
	
	.. code-block:: python
	
	linear, angular = get_units()
	linear, angular, time = get_units(with_time=True)
	"""
	...

def set_path_blending(enable: bool, blend_radius: typing.Union[float, None] = None) -> None:
	"""
	Enables or disables path blending and sets the blend radius.
	
	:param enable: Enable or disable path blending.
	:param blend_radius: The blend radius between moves in meters.
	
	**Examples**
	
	.. code-block:: python
	
	set_path_blending(True, 0.0)  # enable path blending, blend radius 0.0m
	movej(waypoint1)
	movej(waypoint2)
	movej(waypoint3)
	sync()  # moves executed before this command
	set_path_blending(False)  # disable path blending again
	"""
	...

def set_machine_frame(pose: typing.Union[Pose, str], instance: str = '') -> None:
	"""
	Sets the origin frame for the 3D visualization of the PathPilot remote
	machine model.
	
	:param pose:  Pose to use for the machine frame.
	:param instance: Optional machine instance name. If not given, default instance is used.
	
	**Examples**
	
	.. code-block:: python
	
	set_machine_frame(p[0,0,0,90,0,0], "instance")
	set_machine_frame(Pose(x=100))  # sets frame for default instance
	"""
	...

def set_param(name: str, value: object) -> None:
	"""
	Sets a user parameter to a the defined value.
	
	:param name: Parameter name.
	:param value: Value to store.
	
	.. code-block:: python
	
	set_param("my_waypoint", waypoint1)
	"""
	...

def get_param(name: str, default: object = None) -> object:
	"""
	Fetch a stored user parameter.
	
	:param name: Parameter name.
	:param default: Default value return if the parameter is not defined.
	:return: Returns a base Python type, construct rpl types or returns a dict if the parameter is set,
	else returns the default value.
	
	**Examples**
	
	.. code-block:: python
	
	wp = get_param("my_waypoint", Pose())
	"""
	...

def delete_param(name: str) -> None:
	"""
	Removes a user parameter
	
	:param name: Parameter name to delete
	
	.. code-block:: python
	
	delete_param("my_waypoint")
	"""
	...

def load_trajectory(file_path: str) -> trajectory_msgs.msg._JointTrajectory.JointTrajectory:
	"""
	Loads a raw joint trajectory from a CSV file and returns them in ROS format.
	
	:param file_path: Path of the CSV file.
	:return: A ROS joint trajectory.
	"""
	...

def execute_trajectory(trajectory: trajectory_msgs.msg._JointTrajectory.JointTrajectory, v: float = None, retime: bool = False, velocity_scale: float = 1.0) -> None:
	"""
	The execute trajectory command executes a ROS JointTrajectory. Before
	running the joint trajectory, the robot moves to the start joint position
	using a joint move command.
	:param velocity_scale: move velocity scaling factor 0.0 - 1.0
	:param trajectory: a ROS joint trajectory
	:param retime: Enable retiming the trajectory to make use of the velocity scaling.
	
	:param v: move velocity scaling factor 0.0 - 1.0
	
	.. deprecated:: 3.1.1
	use velocity_scale instead
	"""
	...

def save_trajectory(file_path: str, trajectory: trajectory_msgs.msg._JointTrajectory.JointTrajectory) -> None:
	"""
	The save trajectory command saves a joint trajectory to a CSV file.
	
	:param file_path: Path of the CSV file.
	:param trajectory: The joint trajectory to save.
	"""
	...

def to_local_pose(global_pose, apply_work_offset: bool = True, apply_tool_offset: bool = True) -> Pose:
	"""
	Converts a global pose to a local pose
	
	:param global_pose: Global workspace Pose to convert to local coordinates (based on specified arguments)
	:param apply_work_offset: Applies the active work offset
	:param apply_tool_offset: Applies the active tool offset
	:return: converted local pose
	
	**Examples**
	
	.. code-block:: python
	
	local_pose = to_local_pose(global_pose)
	work_only_pose = to_local_pose(global_pose, apply_tool_offset=False)
	"""
	...

def register_interrupt(source: InterruptSource, nr_or_name: typing.Union[int, str], fct: typing.Callable[]) -> None:
	"""
	Registers a interrupt function to an interrupt source.
	
	:param source: The interrupt source type.
	:param nr_or_name: Number or name of the interrupt source, e.g. 1 for Digital Input 1.
	:param fct: The function which should be called when the interrupt is triggered,
	if None is passed, this unregisters and disables the interrupt.
	
	**Examples**
	
	.. code-block:: python
	
	def interrupt_handler(value):
	if value:
	exit() # exit program when digital input 1 is high
	
	register_interrupt(InterruptSource.DigitalInput, 1, interrupt_handler)
	"""
	...

def trigger_interrupt(nr: int, value: typing.Any[]) -> None:
	"""
	Triggers a program interrupt.
	
	:param nr: Program interrupt number which should be triggered.
	:param value: Value which is passed along with the triggered interrupt.
	
	**Examples**
	
	.. code-block:: python
	
	trigger_interrupt(2, 342.34)
	"""
	...

def actuate_gripper(position: float, effort: float = 0.2, wait: bool = True):
	"""
	Actuate the gripper to a given position.
	
	:param position: Target gripper position in range 0.0 to 1.0.
	:param effort: Effort for the actuation in range 0.0 to 1.0.
	:param wait: Wait for the gripper to reach the target position.
	
	**Examples**
	
	.. code-block:: python
	
	actuate_gripper(0.5) # actuate to 50% position
	actuate_gripper(1.0, 0.3) # actuate to 100% position with 30% effort
	actuate_gripper(0.0, wait=True) # actuate to 0% position and wait for completion
	"""
	...

def get_gripper_position() -> float:
	"""
	Returns the current gripper position.
	
	:return: Current gripper position.
	
	**Examples**
	
	.. code-block:: python
	
	gripper_position = get_gripper_position()
	"""
	...

def allowed_configurations(config_mask_object) -> None:
	...

def set_work_offset(args, kwargs) -> None:
	...

def set_tool_offset(args, kwargs) -> None:
	...

def get_work_offset(args, kwargs) -> typing.Union[Pose, None]:
	...

def get_tool_offset(args, kwargs) -> typing.Union[Pose, None]:
	...

def change_work_offset(args, kwargs) -> None:
	...

def change_tool_offset(args, kwargs) -> None:
	...

def set_machine_offset(args, kwargs) -> None:
	...

def work_offset(args, kwargs):
	...

